# C - Sorting algorithms & Big O

This project is done by Lamyaa Alghaihab and Lina Alduaylij.

## Tasks

###  Task0. Bubble sort
IN this task we write a function that sorts an array of integers in ascending order using the Bubble sort algorithm
* Prototype: void `bubble_sort(int *array, size_t size);`
* We will print the array after each time you swap two elements.

Write in the file 0-O, the big O notations of the time complexity of the Bubble sort algorithm, with 1 notation per line:

* in the best case
* in the average case
* in the worst case

### Task1. Insertion sort
In this task we write a function that sorts a doubly linked list of integers in ascending order using the Insertion sort algorithm

* Prototype:`void insertion_sort_list(listint_t **list);`
* The function will swap the nodes themselves.
* The function will print the list after each time you swap two elements.

Write in the file `1-O`, the big O notations of the time complexity of the Insertion sort algorithm, with 1 notation per line:

* in the best case
* in the average case
* in the worst case

### Task2. Selection sort
In this task we write a function that sorts an array of integers in ascending order using the Selection sort algorithm

* Prototype: `void selection_sort(int *array, size_t size);`
* The function will print the array after each time you swap two elements.

Write in the file `2-O`, the big O notations of the time complexity of the Selection sort algorithm, with 1 notation per line:

* in the best case
* in the average case
* in the worst case

### Task3. Quick sort
In this task we will write a function that sorts an array of integers in ascending order using the Quick sort algorithm

* Prototype: `void quick_sort(int *array, size_t size);`
* The pivot will always be the last element of the partition being sorted.
* The function will print the array after each time you swap two elements.

Write in the file `3-O`, the big O notations of the time complexity of the Quick sort algorithm, with 1 notation per line:

* in the best case
* in the average case
* in the worst case

